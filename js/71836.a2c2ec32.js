"use strict";(globalThis["webpackChunkquasar_dev"]=globalThis["webpackChunkquasar_dev"]||[]).push([[71836],{71836:(e,s,a)=>{a.r(s),a.d(s,{default:()=>m});var n=a(83673);const o=(0,n._)("p",null,"一个SSR应用在服务器和客户端上运行的代码是一样的。在.vue SFC文件中声明一个Vue指令(或直接导入它)通常足以让它在非SSR构建中工作。但在SSR构建中，由于Vue 3的架构(当使用vue-loader处理.vue文件时，像 Quasar 那样)，它需要一些额外的工作。本页将告诉你需要做什么。",-1),t=(0,n._)("p",null,"当构建你的应用程序的服务器端时，Vue要求你为你的每个自定义Vue指令指定SSR转换，否则它会出错，说它不知道如何在你的SFC模板中处理该特定指令。",-1),c=(0,n._)("div",{class:"doc-note doc-note--tip"},[(0,n._)("p",{class:"doc-note__title"},"TIP"),(0,n._)("p",null,"你不需要为 Quasar 提供的Vue指令做任何工作。Quasar App CLI已经处理了声明SSR转换的问题。")],-1),l=(0,n._)("p",null,[(0,n.Uk)("当添加SSR模式时， Quasar CLI 将创建"),(0,n._)("code",{class:"doc-token"},"src-ssr/directives"),(0,n.Uk)("文件夹。它将观察这个文件夹中的任何.js(或.ts，如果启用了TS)文件，并将这些转换注入到构建中。")],-1),r=(0,n._)("p",null,[(0,n.Uk)("假设我们有一个名为"),(0,n._)("code",{class:"doc-token"},"my-dir"),(0,n.Uk)("的自定义Vue指令，并在我们的应用程序中使用。我们已经将其声明或导入到我们的应用程序中，但现在为了使SSR的服务器端代码正确运行，我们现在需要为其创建一个文件。由于该指令被命名为"),(0,n._)("code",{class:"doc-token"},"my-dir"),(0,n.Uk)("，我们将创建"),(0,n._)("code",{class:"doc-token"},"my-dir.js"),(0,n.Uk)("文件。")],-1),d=(0,n._)("pre",{class:"doc-code language-js"},[(0,n._)("code",{class:"doc-code__inner doc-code__inner--prerendered language-js"},[(0,n._)("span",{class:"token comment"},"// src-ssr/directives/my-dir.js"),(0,n.Uk)("\n\n"),(0,n._)("span",{class:"token keyword"},"export"),(0,n.Uk)(),(0,n._)("span",{class:"token keyword"},"default"),(0,n.Uk)(),(0,n._)("span",{class:"token punctuation"},"("),(0,n._)("span",{class:"token parameter"},"dir"),(0,n._)("span",{class:"token punctuation"},")"),(0,n.Uk)(),(0,n._)("span",{class:"token operator"},"=>"),(0,n.Uk)(),(0,n._)("span",{class:"token punctuation"},"{"),(0,n.Uk)("\n  "),(0,n._)("span",{class:"token keyword"},"return"),(0,n.Uk)(),(0,n._)("span",{class:"token punctuation"},"{"),(0,n.Uk)("\n    "),(0,n._)("span",{class:"token literal-property property"},"props"),(0,n._)("span",{class:"token operator"},":"),(0,n.Uk)(),(0,n._)("span",{class:"token punctuation"},"["),(0,n._)("span",{class:"token punctuation"},"]"),(0,n.Uk)("\n  "),(0,n._)("span",{class:"token punctuation"},"}"),(0,n.Uk)("\n"),(0,n._)("span",{class:"token punctuation"},"}"),(0,n.Uk)("\n")])],-1),u=(0,n._)("p",null,[(0,n.Uk)("上面的内容基本上是我们指令的Noop SSR转换。根据你的Vue指令在客户端的作用，你应该编写适当的Vue SSR转换。然后，你应该为你所有的"),(0,n._)("strong",null,"非Quasar"),(0,n.Uk)("Vue指令重复这一过程。")],-1),p=(0,n._)("div",{class:"doc-note doc-note--tip"},[(0,n._)("p",{class:"doc-note__title"},"TIP"),(0,n._)("p",null,"请前往Vue 3文档，它应该解释了如何为你的指令写一个Vue SSR转换。请注意，在写这些行文的时候，Vue 3的SSR文档网站仍然不完整。")],-1),i=(0,n._)("p",null,"如果不确定如何编写必要的转换函数，那么只需对你的所有指令使用上述代码样本中的noop转换。",-1),k=(0,n._)("div",{class:"doc-note doc-note--danger"},[(0,n._)("p",{class:"doc-note__title"},"WARNING"),(0,n._)("p",null,[(0,n.Uk)("你需要确保的是，文件的名称与你的指令的"),(0,n._)("strong",null,"kebab大小写"),(0,n.Uk)("名称一致。")])],-1),_=(0,n._)("p",null,[(0,n.Uk)("由于这些转换是提供给vue-loader的，每当你直接在"),(0,n._)("code",{class:"doc-token"},"src-ssr/directives"),(0,n.Uk)("文件夹下添加/删除/改变任何文件，开发服务器将自动重启。这意味着改变的代价很高，所以你应该牢记这一点。")],-1);function S(e,s,a,S,U,g){const v=(0,n.up)("doc-page");return(0,n.wg)(),(0,n.j4)(v,{"meta-title":S.metaTitle,title:"Vue SSR指令",nav:S.nav,toc:S.toc,"meta-desc":S.metaDesc},{default:(0,n.w5)((()=>[o,t,c,(0,n._)("h2",{id:"如何声明一个指令",class:"doc-heading doc-h2",onClick:s[0]||(s[0]=e=>S.copyHeading("如何声明一个指令"))},"如何声明一个指令"),l,r,d,u,p,i,k,(0,n._)("h2",{id:"热模块重新加载",class:"doc-heading doc-h2",onClick:s[1]||(s[1]=e=>S.copyHeading("热模块重新加载"))},"热模块重新加载"),_])),_:1},8,["meta-title","nav","toc","meta-desc"])}var U=a(17536);const g={name:"DocMarkdownPage",setup(){return{metaTitle:"Vue SSR指令",metaDesc:"在 Quasar 应用中管理SSR的Vue指令。",nav:[{name:"SSR 生产导出",category:"开发 SSR",path:"/quasar-cli/developing-ssr/ssr-production-export",dir:"left"},{name:"SSR 的应用程序图标",category:"开发 SSR",path:"/quasar-cli/developing-ssr/app-icons-ssr",dir:"right"}],toc:[{id:"如何声明一个指令",title:"如何声明一个指令"},{id:"热模块重新加载",title:"热模块重新加载"}],copyHeading:U.Et}}};var v=a(74260);const R=(0,v.Z)(g,[["render",S]]),m=R}}]);