"use strict";(globalThis["webpackChunkquasar_dev"]=globalThis["webpackChunkquasar_dev"]||[]).push([[1462],{1462:(e,t,l)=>{l.r(t),l.d(t,{default:()=>b});var n=l(83673);const i=(0,n._)("p",null,"You can morph one DOM element into another (with animation) or between two states of the same element using Quasar’s morph util described below.",-1),a=(0,n.Uk)("Might also be worth to look at the "),o=(0,n.Uk)("Morph directive"),s=(0,n.Uk)(" which uses this util but it’s simpler to use."),r=(0,n._)("pre",{class:"doc-code language-js"},[(0,n._)("code",{class:"doc-code__inner doc-code__inner--prerendered language-js"},[(0,n._)("span",{class:"token keyword"},"import"),(0,n.Uk)(),(0,n._)("span",{class:"token punctuation"},"{"),(0,n.Uk)(" morph "),(0,n._)("span",{class:"token punctuation"},"}"),(0,n.Uk)(),(0,n._)("span",{class:"token keyword"},"from"),(0,n.Uk)(),(0,n._)("span",{class:"token string"},"'quasar'"),(0,n.Uk)("\n\n"),(0,n._)("span",{class:"token comment"},"// Morph one DOM element to another:"),(0,n.Uk)("\n"),(0,n._)("span",{class:"token keyword"},"const"),(0,n.Uk)(" cancelMorph "),(0,n._)("span",{class:"token operator"},"="),(0,n.Uk)(),(0,n._)("span",{class:"token function"},"morph"),(0,n._)("span",{class:"token punctuation"},"("),(0,n._)("span",{class:"token punctuation"},"{"),(0,n.Uk)("\n  "),(0,n._)("span",{class:"token literal-property property"},"from"),(0,n._)("span",{class:"token operator"},":"),(0,n.Uk)(),(0,n._)("span",{class:"token string"},"'#from-el'"),(0,n._)("span",{class:"token punctuation"},","),(0,n.Uk)("\n  "),(0,n._)("span",{class:"token literal-property property"},"to"),(0,n._)("span",{class:"token operator"},":"),(0,n.Uk)(),(0,n._)("span",{class:"token string"},"'#to-el'"),(0,n.Uk)("\n"),(0,n._)("span",{class:"token punctuation"},"}"),(0,n._)("span",{class:"token punctuation"},")"),(0,n.Uk)("\n\n"),(0,n._)("span",{class:"token comment"},"// call cancelMorph() to cancel the morphing"),(0,n.Uk)("\n")])],-1),u=(0,n._)("p",null,"The function expects one mandatory Object parameter with the following keys:",-1),d=(0,n._)("thead",null,[(0,n._)("tr",null,[(0,n._)("th",{class:"text-left"},"Name"),(0,n._)("th",{class:"text-left"},"Type"),(0,n._)("th",{class:"text-left"},"Default value"),(0,n._)("th",{class:"text-left"},"Description")])],-1),c=(0,n._)("tbody",null,[(0,n._)("tr",null,[(0,n._)("td",null,"from"),(0,n._)("td",null,"DOM"),(0,n._)("td",null,"-"),(0,n._)("td",null,[(0,n.Uk)("("),(0,n._)("strong",null,"required"),(0,n.Uk)(") A DOM element or CSS selector or a function returning a DOM element")])]),(0,n._)("tr",null,[(0,n._)("td",null,"to"),(0,n._)("td",null,"DOM"),(0,n._)("td",null,"-"),(0,n._)("td",null,"Same as “from”; if “to” is missing, then it is assumes that it is the same as “from”")]),(0,n._)("tr",null,[(0,n._)("td",null,"onToggle()"),(0,n._)("td",null,"Function"),(0,n._)("td",null,"-"),(0,n._)("td",null,"A synchronous toggle function that will be executed immediately after the state of the initial element is saved. Use a function that toggles the state of the components so that the destination element becomes available.")]),(0,n._)("tr",null,[(0,n._)("td",null,"waitFor"),(0,n._)("td",null,"Number/‘transitioned’/Promise"),(0,n._)("td",null,"0"),(0,n._)("td",null,[(0,n.Uk)("A number, ‘transitionend’ or a Promise - it will delay animation start for that number of milliseconds, or until a ‘transitionend’ event is emitted by the destination element, or until the promise is resolved (if the promise is rejected the morphing will abort, but the "),(0,n._)("code",{class:"doc-token"},"toggle function"),(0,n.Uk)(" was already called)")])]),(0,n._)("tr",null,[(0,n._)("td",null,"duration"),(0,n._)("td",null,"Number"),(0,n._)("td",null,"300"),(0,n._)("td",null,"The duration in milliseconds for the animation")]),(0,n._)("tr",null,[(0,n._)("td",null,"easing"),(0,n._)("td",null,"String"),(0,n._)("td",null,"‘ease-in-out’"),(0,n._)("td",null,"The timing function for the animation (CSS easing format)")]),(0,n._)("tr",null,[(0,n._)("td",null,"delay"),(0,n._)("td",null,"Number"),(0,n._)("td",null,"0"),(0,n._)("td",null,"The delay in milliseconds for the animation")]),(0,n._)("tr",null,[(0,n._)("td",null,"fill"),(0,n._)("td",null,"String"),(0,n._)("td",null,"‘none’"),(0,n._)("td",null,"The fill mode for the animation")]),(0,n._)("tr",null,[(0,n._)("td",null,"style"),(0,n._)("td",null,"String/Object"),(0,n._)("td",null,"-"),(0,n._)("td",null,"The extra style to be applied to the morphing element while it is animated (either as string or a CSSStyleDeclaration object)")]),(0,n._)("tr",null,[(0,n._)("td",null,"classes"),(0,n._)("td",null,"String"),(0,n._)("td",null,"-"),(0,n._)("td",null,"The extra classes to be applied to the morphing element while it is animated (as string)")]),(0,n._)("tr",null,[(0,n._)("td",null,"resize"),(0,n._)("td",null,"Boolean"),(0,n._)("td",null,[(0,n._)("em",null,"false")]),(0,n._)("td",null,"Force resizing instead of the default scaling transformation")]),(0,n._)("tr",null,[(0,n._)("td",null,"useCSS"),(0,n._)("td",null,"Boolean"),(0,n._)("td",null,[(0,n._)("em",null,"false")]),(0,n._)("td",null,"Force use of CSS instead of the Animation API")]),(0,n._)("tr",null,[(0,n._)("td",null,"hideFromClone"),(0,n._)("td",null,"Boolean"),(0,n._)("td",null,[(0,n._)("em",null,"false")]),(0,n._)("td",null,"By default a clone of the initial element is used to fill the space after the element is removed - set this flag if the initial element is not removed or resizing of the space occupied by the initial element is not desired")]),(0,n._)("tr",null,[(0,n._)("td",null,"keepToClone"),(0,n._)("td",null,"Boolean"),(0,n._)("td",null,[(0,n._)("em",null,"false")]),(0,n._)("td",null,"By default the final element is removed from it’s final position to be animated - set this flag to keep a copy in the final position")]),(0,n._)("tr",null,[(0,n._)("td",null,"tween"),(0,n._)("td",null,"Boolean"),(0,n._)("td",null,[(0,n._)("em",null,"false")]),(0,n._)("td",null,"By default the final element is morphed from the position and aspect of the initial element to the ones of the final element - set this flag to use an opacity tween between the initial and final elements")]),(0,n._)("tr",null,[(0,n._)("td",null,"tweenFromOpacity"),(0,n._)("td",null,"Number"),(0,n._)("td",null,"0.6"),(0,n._)("td",null,[(0,n.Uk)("If using "),(0,n._)("strong",null,"tween"),(0,n.Uk)(" it is the initial opacity of the initial element (will be animated to 0) - the initial element is placed on top of the destination element")])]),(0,n._)("tr",null,[(0,n._)("td",null,"tweenToOpacity"),(0,n._)("td",null,"Number"),(0,n._)("td",null,"0.5"),(0,n._)("td",null,[(0,n.Uk)("If using "),(0,n._)("strong",null,"tween"),(0,n.Uk)(" it is the initial opacity of the destination element (will be animated to 1)")])]),(0,n._)("tr",null,[(0,n._)("td",null,"onEnd(direction, aborted)"),(0,n._)("td",null,"Function"),(0,n._)("td",null,"-"),(0,n._)("td",null,"A function that will be called once the morphing is finalized - receives two params: “direction” is a string (‘to’ if the morphing was finished in the final state or ‘from’ if it was finished in the initial state) and “aborted” is a boolean (true means that the animation was aborted)")])],-1),h=(0,n._)("ol",null,[(0,n._)("li",null,"Get the aspect and position of the initial element (if a function is provided for getting the initial element it will be called)"),(0,n._)("li",null,"Calculate the size and position of the container of the initial element"),(0,n._)("li",null,"If another morphing was using the same element that morphing will be aborted"),(0,n._)("li",null,"Execute the onToggle() function (if present)"),(0,n._)("li",null,"Recalculate the size and position of the container of the initial element to check if they are changed"),(0,n._)("li",null,"In the next tick (to allow Vue to process the state changes) the final element will be identified (if a function is provided for getting the final element it will be called)"),(0,n._)("li",null,"If another morphing was using the same element that morphing will be aborted"),(0,n._)("li",null,"Calculate the size and position of the container of the final element"),(0,n._)("li",null,[(0,n.Uk)("If a "),(0,n._)("strong",null,"waitFor"),(0,n.Uk)(" is provided, wait that number of milliseconds, for a ‘transitionend’ event or until the promise is resolved (if the promise is rejected then the morphing is aborted)")]),(0,n._)("li",null,"Recalculate the size and position of the container of the final element to check if they are changed"),(0,n._)("li",null,"Get the aspect and position of the final element"),(0,n._)("li",null,"Start the animation")],-1),m=(0,n._)("p",null,"Regarding the cancel() function (the return value of a call to morph()):",-1),_=(0,n._)("ul",null,[(0,n._)("li",null,[(0,n.Uk)("If the "),(0,n._)("code",{class:"doc-token"},"cancel"),(0,n.Uk)(" function that was returned is called during steps 1 to 11 then the morphing will be aborted (the "),(0,n._)("code",{class:"doc-token"},"toggle function"),(0,n.Uk)(" will still be called if the cancel comes after step 4) and the returned value will be "),(0,n._)("strong",null,"false"),(0,n.Uk)(".")]),(0,n._)("li",null,[(0,n.Uk)("If the "),(0,n._)("code",{class:"doc-token"},"cancel"),(0,n.Uk)(" function is called between the start and end of the animation then the animation will be reversed and the returned value will be "),(0,n._)("strong",null,"true"),(0,n.Uk)(".")]),(0,n._)("li",null,[(0,n.Uk)("If the "),(0,n._)("code",{class:"doc-token"},"cancel"),(0,n.Uk)(" function is called after the end of the animation nothing will happen and the returned value will be "),(0,n._)("strong",null,"false"),(0,n.Uk)(".")])],-1);function p(e,t,l,p,f,g){const k=(0,n.up)("doc-link"),w=(0,n.up)("q-markup-table"),b=(0,n.up)("doc-example"),y=(0,n.up)("doc-page");return(0,n.wg)(),(0,n.j4)(y,{"meta-title":p.metaTitle,title:"Morph Utils",related:p.related,toc:p.toc,"meta-desc":p.metaDesc},{default:(0,n.w5)((()=>[i,(0,n._)("p",null,[a,(0,n.Wm)(k,{to:"/vue-directives/morph"},{default:(0,n.w5)((()=>[o])),_:1}),s]),(0,n._)("h2",{id:"basic-usage",class:"doc-heading doc-h2",onClick:t[0]||(t[0]=e=>p.copyHeading("basic-usage"))},"Basic usage"),r,u,(0,n.Wm)(w,{"wrap-cells":!0,flat:!0,bordered:!0,style:{width:"fit-content","max-width":"100%"}},{default:(0,n.w5)((()=>[d,c])),_:1}),(0,n._)("h2",{id:"morphing-lifecycle",class:"doc-heading doc-h2",onClick:t[1]||(t[1]=e=>p.copyHeading("morphing-lifecycle"))},"Morphing lifecycle"),h,m,_,(0,n._)("h2",{id:"examples",class:"doc-heading doc-h2",onClick:t[2]||(t[2]=e=>p.copyHeading("examples"))},"Examples"),(0,n.Wm)(b,{title:"Morphing the same element",file:"MorphUtils/SameElement"}),(0,n.Wm)(b,{title:"Morphing a QCard from a QFabAction",file:"MorphUtils/FabCard"}),(0,n.Wm)(b,{title:"Image gallery ",file:"MorphUtils/ImageGallery"}),(0,n.Wm)(b,{title:"Horizontal image strip ",file:"MorphUtils/ImageStripHorizontal"}),(0,n.Wm)(b,{title:"Vertical image strip ",file:"MorphUtils/ImageStripVertical"})])),_:1},8,["meta-title","related","toc","meta-desc"])}var f=l(17536);const g={name:"DocMarkdownPage",setup(){return{metaTitle:"Morph Utils",metaDesc:"Morph one DOM element into another (with animation) or between two states of the same element using Quasar's morph util.",related:[{name:"变形",category:"Vue 指令",path:"/vue-directives/morph"}],toc:[{id:"basic-usage",title:"Basic usage"},{id:"morphing-lifecycle",title:"Morphing lifecycle"},{id:"examples",title:"Examples"}],copyHeading:f.Et}}};var k=l(74260);const w=(0,k.Z)(g,[["render",p]]),b=w}}]);